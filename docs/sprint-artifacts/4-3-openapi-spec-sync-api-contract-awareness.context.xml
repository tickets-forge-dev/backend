<story-context id=".bmad/bmm/workflows/4-implementation/story-context/template" v="1.0">
  <metadata>
    <epicId>4</epicId>
    <storyId>4.3</storyId>
    <title>OpenAPI Spec Sync - API Contract Awareness</title>
    <status>drafted</status>
    <generatedAt>2026-02-02T18:29:13.223Z</generatedAt>
    <generator>BMAD Story Context Workflow</generator>
    <sourceStoryPath>docs/sprint-artifacts/4-3-openapi-spec-sync-api-contract-awareness.md</sourceStoryPath>
  </metadata>

  <story>
    <asA>backend system</asA>
    <iWant>to pull and validate OpenAPI specs from repositories</iWant>
    <soThat>tickets reference actual API contracts and detect drift</soThat>
    <tasks>
      - Create ApiSpec domain entity
      - Implement IApiSpecIndexer application service interface
      - Build ApiSpecIndexerImpl infrastructure implementation
      - Implement ApiSpecRepository for Firestore operations
      - Add OpenAPI spec detection logic
      - Parse and validate specs using swagger-parser
      - Compute SHA-256 hash for specs
      - Extract endpoints with schemas
      - Implement findEndpointsByIntent query interface
      - Write unit tests for indexer and repository
      - Write integration tests for E2E indexing
    </tasks>
  </story>

  <acceptanceCriteria>
    AC1: System detects OpenAPI spec files (openapi.yaml, openapi.json, swagger.yaml) in repo
    AC2: System parses and validates OpenAPI 3.0/3.1 specs
    AC3: System extracts endpoints, methods, request/response schemas
    AC4: System computes SHA-256 hash of spec content
    AC5: System stores spec metadata in Firestore collection /workspaces/{workspaceId}/apiSpecs/{specId}
    AC6: Firestore document contains: repoName, specUrl, hash, endpoints[], version, commitSha, createdAt
    AC7: Invalid OpenAPI files are logged but don't block indexing
    AC8: UI shows warning if spec validation fails
    AC9: Query interface findEndpointsByIntent(intent, specId) returns relevant endpoints
    AC10: When ticket generation references API, includes apiSnapshot: { specUrl, hash }
    AC11: When no spec found in repo, log info message and store hasSpec: false (graceful degradation)
  </acceptanceCriteria>

  <artifacts>
    <docs>
      <doc>
        <path>docs/prd.md</path>
        <title>Product Requirements Document</title>
        <section>System Architecture - Data Snapshots</section>
        <snippet>API snapshot = OpenAPI hash. System maintains API contract awareness for drift detection.</snippet>
      </doc>
      <doc>
        <path>docs/architecture.md</path>
        <title>System Architecture</title>
        <section>Key Dependencies - OpenAPI</section>
        <snippet>OpenAPI: Parsing via @apidevtools/swagger-parser. Auto-generate with @nestjs/swagger. All endpoints documented with type-safe client generation.</snippet>
      </doc>
      <doc>
        <path>docs/architecture.md</path>
        <title>System Architecture</title>
        <section>Epic 4 Technical Details</section>
        <snippet>Epic 4: Code Intelligence & Estimation uses indexing/ module with RepoIndexerService, ApiSpecResolver, EstimationEngine, DriftDetector. Background indexing via Bull queues.</snippet>
      </doc>
      <doc>
        <path>docs/architecture.md</path>
        <title>System Architecture</title>
        <section>Async Processing</section>
        <snippet>Use Bull queues for long-running operations (indexing, drift detection). Redis cache for frequently accessed data (repo indexes, API specs).</snippet>
      </doc>
      <doc>
        <path>docs/architecture.md</path>
        <title>System Architecture</title>
        <section>Architecture Decision Records - Mastra Boundaries</section>
        <snippet>Use Mastra only for 4 LLM-powered steps. All other operations (validation, estimation, indexing, export) use deterministic NestJS services.</snippet>
      </doc>
      <doc>
        <path>docs/epics.md</path>
        <title>Epic Breakdown</title>
        <section>Story 4.3 Details</section>
        <snippet>Covers FR10: System pulls and validates OpenAPI specs for API-aware tickets. Prerequisite: Story 4.2 (Code Indexing) completed.</snippet>
      </doc>
    </docs>

    <code>
      <artifact>
        <path>backend/src/indexing/indexing.module.ts</path>
        <kind>module</kind>
        <symbol>IndexingModule</symbol>
        <reason>Feature module for indexing functionality - extend this for API spec indexing</reason>
      </artifact>
      <artifact>
        <path>backend/src/indexing/application/services/repo-indexer.service.ts</path>
        <kind>service</kind>
        <symbol>RepoIndexerService</symbol>
        <reason>Existing indexer service - reference for indexing patterns, cloning, file walking</reason>
      </artifact>
      <artifact>
        <path>backend/src/indexing/domain/IndexRepository.ts</path>
        <kind>interface</kind>
        <symbol>IndexRepository</symbol>
        <reason>Repository pattern example - follow same pattern for ApiSpecRepository</reason>
      </artifact>
      <artifact>
        <path>backend/src/indexing/infrastructure/persistence/firestore-index.repository.ts</path>
        <kind>repository</kind>
        <symbol>FirestoreIndexRepository</symbol>
        <reason>Firestore repository implementation - use as template for ApiSpecRepository</reason>
      </artifact>
      <artifact>
        <path>backend/src/indexing/application/services/file-parser.service.ts</path>
        <kind>service</kind>
        <symbol>FileParserService</symbol>
        <reason>Parser service pattern - similar approach needed for OpenAPI parsing</reason>
      </artifact>
      <artifact>
        <path>backend/src/shared/infrastructure/github/github-api.service.ts</path>
        <kind>service</kind>
        <symbol>GitHubApiService</symbol>
        <reason>GitHub API integration - may need to fetch spec files from repos</reason>
      </artifact>
      <artifact>
        <path>backend/src/indexing/application/jobs/indexing.processor.ts</path>
        <kind>processor</kind>
        <symbol>IndexingProcessor</symbol>
        <reason>Bull queue processor - API spec indexing should integrate with existing indexing jobs</reason>
      </artifact>
    </code>

    <dependencies>
      <node>
        <package name="@apidevtools/swagger-parser" version="^10.1.0" dev="false" notes="NEW - OpenAPI parser and validator" />
        <package name="@nestjs/bull" version="^10.1.0" dev="false" notes="EXISTING - Queue management" />
        <package name="@nestjs/common" version="^10.3.0" dev="false" notes="EXISTING - NestJS core" />
        <package name="@nestjs/config" version="^3.1.1" dev="false" notes="EXISTING - Configuration" />
        <package name="@nestjs/swagger" version="^7.2.0" dev="false" notes="EXISTING - Swagger integration" />
        <package name="simple-git" version="^3.30.0" dev="false" notes="EXISTING - Git operations" />
        <package name="bull" version="^4.12.0" dev="false" notes="EXISTING - Queue library" />
        <package name="firebase-admin" version="^12.0.0" dev="false" notes="EXISTING - Firestore access" />
      </node>
    </dependencies>
  </artifacts>

  <constraints>
    - Follow Clean Architecture: domain entities must not depend on NestJS, Firebase, or external SDKs
    - Place domain entity ApiSpec in backend/src/indexing/domain/ or create separate backend/src/api-specs/domain/
    - Application service IApiSpecIndexer goes in application/services/
    - Infrastructure implementation ApiSpecIndexerImpl in infrastructure/services/
    - Repository in infrastructure/persistence/
    - Use Ports &amp; Adapters pattern for external dependencies (OpenAPI parser)
    - Follow existing repository patterns from RepoIndexerService
    - Store specs in Firestore collection: /workspaces/{workspaceId}/apiSpecs/{specId}
    - Use Node.js crypto module for SHA-256 hash computation
    - Validate specs but continue indexing on validation failure
    - Log validation errors to Firestore /logs collection
    - Graceful degradation: if no spec found, store hasSpec=false and continue (no errors)
    - Integrate with existing Bull queue indexing workflow
    - No business logic in presentation layer (controllers)
    - All tests must pass 100% before story is done
    - Use TypeScript strict mode
    - Follow existing naming conventions: kebab-case for files, PascalCase for classes
  </constraints>

  <interfaces>
    <interface>
      <name>IApiSpecIndexer</name>
      <kind>TypeScript Interface</kind>
      <signature>
        interface IApiSpecIndexer {
          indexApiSpecs(workspaceId: string, repoName: string, commitSha: string): Promise&lt;void&gt;;
          findEndpointsByIntent(intent: string, specId: string): Promise&lt;ApiEndpoint[]&gt;;
          getSpecByRepo(workspaceId: string, repoName: string): Promise&lt;ApiSpec | null&gt;;
        }
      </signature>
      <path>backend/src/indexing/application/services/ApiSpecIndexer.ts</path>
    </interface>
    <interface>
      <name>ApiSpecRepository</name>
      <kind>TypeScript Interface</kind>
      <signature>
        interface ApiSpecRepository {
          save(apiSpec: ApiSpec): Promise&lt;void&gt;;
          findByRepo(workspaceId: string, repoName: string): Promise&lt;ApiSpec | null&gt;;
          findById(specId: string): Promise&lt;ApiSpec | null&gt;;
          update(specId: string, updates: Partial&lt;ApiSpec&gt;): Promise&lt;void&gt;;
        }
      </signature>
      <path>backend/src/indexing/domain/ApiSpecRepository.ts</path>
    </interface>
    <interface>
      <name>ApiSpec Domain Entity</name>
      <kind>TypeScript Interface</kind>
      <signature>
        interface ApiSpec {
          id: string;
          workspaceId: string;
          repoName: string;
          specUrl: string;
          hash: string;
          endpoints: ApiEndpoint[];
          version: string;
          commitSha: string;
          hasSpec: boolean;              // false if no spec found in repo
          isValid: boolean;
          validationErrors?: string[];
          createdAt: Date;
          updatedAt: Date;
        }
      </signature>
      <path>backend/src/indexing/domain/entities/ApiSpec.ts</path>
    </interface>
    <interface>
      <name>ApiEndpoint</name>
      <kind>TypeScript Interface</kind>
      <signature>
        interface ApiEndpoint {
          path: string;
          method: string;
          operationId?: string;
          summary?: string;
          requestSchema?: object;
          responseSchema?: object;
        }
      </signature>
      <path>backend/src/indexing/domain/entities/ApiSpec.ts</path>
    </interface>
    <interface>
      <name>Firestore Collection Path</name>
      <kind>Firestore Collection</kind>
      <signature>/workspaces/{workspaceId}/apiSpecs/{specId}</signature>
      <path>Firestore Database</path>
    </interface>
  </interfaces>

  <tests>
    <standards>
      Follow existing testing patterns in backend/src/indexing tests. Use Jest for unit tests, NestJS testing utilities for integration tests. Mock external dependencies (GitHub API, Firestore, swagger-parser). Test files should be colocated with source in __tests__ directories or .spec.ts files. Aim for 100% coverage of new code. Test both happy paths and error scenarios.
    </standards>

    <locations>
      backend/src/indexing/application/services/__tests__/
      backend/src/indexing/infrastructure/persistence/__tests__/
      backend/src/indexing/domain/__tests__/
    </locations>

    <ideas>
      <test ac="AC1" desc="Detects openapi.yaml in repo root" />
      <test ac="AC1" desc="Detects openapi.json in /docs directory" />
      <test ac="AC1" desc="Detects swagger.yaml in /api-docs directory" />
      <test ac="AC2" desc="Parses valid OpenAPI 3.0 spec successfully" />
      <test ac="AC2" desc="Parses valid OpenAPI 3.1 spec successfully" />
      <test ac="AC2" desc="Validates spec structure" />
      <test ac="AC3" desc="Extracts all endpoints from spec" />
      <test ac="AC3" desc="Extracts HTTP methods correctly" />
      <test ac="AC3" desc="Extracts request/response schemas" />
      <test ac="AC4" desc="Computes SHA-256 hash consistently" />
      <test ac="AC4" desc="Same spec content produces same hash" />
      <test ac="AC5" desc="Saves spec to Firestore at correct path" />
      <test ac="AC6" desc="Firestore document includes all required fields" />
      <test ac="AC7" desc="Invalid spec logs error but continues" />
      <test ac="AC7" desc="Malformed JSON spec handled gracefully" />
      <test ac="AC8" desc="Validation failure sets isValid=false" />
      <test ac="AC9" desc="findEndpointsByIntent returns matching endpoints" />
      <test ac="AC9" desc="Intent matching works with keywords" />
      <test ac="AC10" desc="Generated ticket includes apiSnapshot with hash" />
      <test ac="AC11" desc="No spec found logs info and stores hasSpec=false" />
      <test ac="AC11" desc="No spec found does not throw error or block indexing" />
      <test ac="AC11" desc="Repos without specs can still generate tickets (no API snapshot)" />
    </ideas>
  </tests>
</story-context>
