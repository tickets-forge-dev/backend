<story-context id=".bmad/bmm/workflows/4-implementation/story-context/template" v="1.0">
  <metadata>
    <epicId>4</epicId>
    <storyId>1</storyId>
    <title>GitHub App Integration - Read-Only Repo Access</title>
    <status>drafted</status>
    <generatedAt>2026-02-01</generatedAt>
    <generator>BMAD Story Context Workflow</generator>
    <sourceStoryPath>docs/sprint-artifacts/4-1-github-app-integration-read-only-repo-access.md</sourceStoryPath>
  </metadata>

  <story>
    <asA>Product Manager</asA>
    <iWant>connect my GitHub organization to Executable Tickets</iWant>
    <soThat>the system can read my codebase and generate code-aware tickets</soThat>
    <tasks>
- Task 1: GitHub App Setup (AC: #1, #2) - Manual OAuth app creation in GitHub Developer Settings
- Task 2: Backend OAuth Controller (AC: #2, #3) - Create /api/github/oauth endpoints
- Task 3: GitHub Token Service (AC: #3, #6) - Token exchange, refresh, revocation, encryption
- Task 4: GitHub Integration Repository (AC: #3) - Firestore persistence for tokens
- Task 5: Repository List Endpoint (AC: #4) - GET /api/github/repositories
- Task 6: Repository Selection Endpoint (AC: #5) - POST /api/github/repositories/select
- Task 7: Webhook Handler (AC: #6) - POST /api/webhooks/github for push/PR events
- Task 8: Frontend Settings Page (AC: #1, #4, #5, #7) - GitHubIntegration component
- Task 9: Frontend GitHub Service (AC: #2, #4) - OAuth and repo management methods
- Task 10: Settings Store (AC: #1) - Zustand store for GitHub connection state
- Task 11: Update RepositorySelector (AC: #5) - Use connected repos instead of manual input
- Task 12: Write Tests - Unit and integration tests for OAuth flow and webhooks
    </tasks>
  </story>

  <acceptanceCriteria>
1. **Settings Integration Page** - Settings UI with Connect GitHub button and OAuth flow explanation
2. **GitHub OAuth Flow** - OAuth popup/redirect with read:repo, read:org, read:user permissions
3. **Token Exchange & Storage** - Backend exchanges code for token, stores encrypted in Firestore
4. **Repository List Display** - Fetches and displays user's accessible repositories with metadata
5. **Repository Selection for Indexing** - User can select repos, persisted to workspace settings
6. **Webhook Configuration** - Backend registers webhook for push/pull_request events
7. **Disconnection Flow** - User can disconnect with confirmation, token revoked
8. **Error Handling** - Handles OAuth blocked, token refresh failures, rate limits, revoked access
  </acceptanceCriteria>

  <artifacts>
    <docs>
      <doc>
        <path>docs/architecture.md</path>
        <title>Architecture: Executable Tickets</title>
        <section>Clean Architecture Pattern</section>
        <snippet>Feature-based modules with internal presentation/application/domain/infrastructure layers. Domain: GitHubIntegration entity (no framework deps), Application: GitHubTokenService, Presentation: GitHubOAuthController, Infrastructure: Firestore repository + @octokit/rest client.</snippet>
      </doc>
      <doc>
        <path>docs/architecture.md</path>
        <title>Architecture: Executable Tickets</title>
        <section>Security Considerations</section>
        <snippet>Tokens stored encrypted in Firestore. Webhook signatures verified using HMAC-SHA256. OAuth state parameter to prevent CSRF. Tokens scoped to workspace (multi-tenancy isolation).</snippet>
      </doc>
      <doc>
        <path>docs/architecture.md</path>
        <title>Architecture: Executable Tickets</title>
        <section>Error Handling Pattern</section>
        <snippet>Domain exceptions (framework-agnostic) mapped to HTTP status codes via exception filter. AECNotFoundError → 404, ValidationFailedError → 400, PermissionDeniedError → 403.</snippet>
      </doc>
      <doc>
        <path>docs/architecture.md</path>
        <title>Architecture: Executable Tickets</title>
        <section>Firestore Collections</section>
        <snippet>/workspaces/{workspaceId}/integrations/github stores { token, repos[] }, /workspaces/{workspaceId}/integrations/jira, /workspaces/{workspaceId}/integrations/linear.</snippet>
      </doc>
      <doc>
        <path>docs/prd_epic4_additions.md</path>
        <title>Epic 4 Additions to PRD</title>
        <section>Story 4.0 - Branch Selection</section>
        <snippet>Story 4.0 (completed) established repository context pattern. Story 4.1 builds on this by enabling OAuth connection to fetch actual user repositories instead of manual input. Uses existing GitHubApiService infrastructure.</snippet>
      </doc>
      <doc>
        <path>docs/sprint-artifacts/4-0-branch-selection-and-default-detection.md</path>
        <title>Story 4.0: Branch Selection & Default Detection</title>
        <section>Learnings - GitHubApiService Already Exists</section>
        <snippet>GitHubApiService at backend/src/shared/infrastructure/github/github-api.service.ts uses @octokit/rest SDK. Has getRepository(), getBranches(), getBranchHead(). Extend this service for repository listing with OAuth tokens.</snippet>
      </doc>
      <doc>
        <path>docs/sprint-artifacts/4-0-branch-selection-and-default-detection.md</path>
        <title>Story 4.0: Branch Selection & Default Detection</title>
        <section>Learnings - Guard Pattern</section>
        <snippet>FirebaseAuthGuard + WorkspaceGuard pattern established. @WorkspaceId() decorator extracts workspaceId. Apply guards to all new OAuth endpoints (except webhook which uses signature verification).</snippet>
      </doc>
    </docs>

    <code>
      <artifact>
        <path>backend/src/shared/infrastructure/github/github-api.service.ts</path>
        <kind>service</kind>
        <symbol>GitHubApiService</symbol>
        <lines>1-234</lines>
        <reason>Existing GitHub API service. Uses Octokit with GITHUB_TOKEN. Has getRepository(), listBranches(), getBranchHead(), verifyRepositoryAccess(). Need to extend with OAuth token support (per-workspace tokens instead of global env token).</reason>
      </artifact>
      <artifact>
        <path>backend/src/shared/presentation/guards/FirebaseAuthGuard.ts</path>
        <kind>guard</kind>
        <symbol>FirebaseAuthGuard</symbol>
        <lines>1-46</lines>
        <reason>Token verification pattern. Extracts Bearer token from Authorization header, verifies with Firebase Admin SDK, attaches decodedToken to request.user. Use this pattern for all OAuth endpoints.</reason>
      </artifact>
      <artifact>
        <path>backend/src/shared/presentation/guards/WorkspaceGuard.ts</path>
        <kind>guard</kind>
        <symbol>WorkspaceGuard</symbol>
        <lines>1-45</lines>
        <reason>Workspace isolation pattern. Extracts workspaceId from Firebase token custom claims or derives from user.uid. Attaches workspaceId to request. Use for OAuth endpoints.</reason>
      </artifact>
      <artifact>
        <path>backend/src/github/github.module.ts</path>
        <kind>module</kind>
        <symbol>GitHubModule</symbol>
        <lines>1-14</lines>
        <reason>Existing GitHub module. Currently minimal with only GitHubController. Need to add: GitHubOAuthController, GitHubTokenService, GitHubIntegrationRepository, GitHubWebhookHandler as providers.</reason>
      </artifact>
      <artifact>
        <path>client/src/stores/auth.store.ts</path>
        <kind>store</kind>
        <symbol>useAuthStore</symbol>
        <lines>1-80</lines>
        <reason>Pattern for Zustand store with Firebase auth. Follow this pattern for settings.store.ts: state (githubConnected, githubRepositories), actions (loadGitHubStatus, selectRepositories, disconnectGitHub), service injection via useServices().</reason>
      </artifact>
      <artifact>
        <path>client/src/services/github.service.ts</path>
        <kind>service</kind>
        <symbol>GitHubService</symbol>
        <lines>1-45</lines>
        <reason>Existing frontend GitHub service. Has getRepository(), getBranches() methods. Extend with OAuth methods: getOAuthUrl(), getConnectionStatus(), listRepositories(), selectRepositories(), disconnect().</reason>
      </artifact>
      <artifact>
        <path>client/src/tickets/components/RepositorySelector.tsx</path>
        <kind>component</kind>
        <symbol>RepositorySelector</symbol>
        <lines>1-120</lines>
        <reason>Current manual input for repository. Update to check GitHub connection status, show dropdown of connected repos if available, fall back to manual input if not connected, show "Connect GitHub" prompt if appropriate.</reason>
      </artifact>
    </code>

    <dependencies>
      <backend>
        <package name="@octokit/rest" version="^20.1.2" usage="GitHub API SDK - already installed" />
        <package name="firebase-admin" version="^12.0.0" usage="Firebase Admin SDK for token verification - already installed" />
        <package name="@nestjs/common" version="^10.3.0" usage="NestJS core - already installed" />
        <package name="@nestjs/config" version="^3.1.1" usage="Environment variables - already installed" />
        <package name="zod" version="^3.22.4" usage="Schema validation for DTOs - already installed" />
        <package name="crypto" builtin="true" usage="Token encryption/decryption, HMAC-SHA256 for webhook signatures" />
      </backend>
      <frontend>
        <package name="axios" version="^1.6.5" usage="HTTP client for API calls - already installed" />
        <package name="zustand" version="^4.5.0" usage="State management - already installed" />
        <package name="lucide-react" version="^0.563.0" usage="Icons for UI - already installed" />
        <package name="@radix-ui/react-dialog" version="^1.1.15" usage="Confirmation dialog for disconnect - already installed" />
      </frontend>
    </dependencies>
  </artifacts>

  <constraints>
1. **Clean Architecture**: Domain layer (GitHubIntegration entity) must have NO framework dependencies. Use interfaces (ports) in application layer.

2. **Token Security**: Tokens MUST be encrypted before storing in Firestore. Use crypto module with workspace-specific encryption key derived from environment secret.

3. **Webhook Security**: Webhook endpoint (/api/webhooks/github) must NOT use FirebaseAuthGuard. Verify webhook signature using HMAC-SHA256 with webhook secret.

4. **Multi-tenancy Isolation**: All OAuth tokens scoped to workspace. Use workspace-specific Octokit instances, not global GITHUB_TOKEN.

5. **OAuth State Parameter**: Include random state parameter in OAuth URL to prevent CSRF attacks. Verify state matches on callback.

6. **Error Handling**: Follow established pattern - domain exceptions (PermissionDeniedError, TokenRefreshFailedError) mapped to HTTP status codes via exception filter.

7. **Repository Pattern**: All Firestore operations via repository interface. GitHubIntegrationRepository implements save(), findByWorkspace(), delete(). Use mappers for domain ↔ Firestore.

8. **Guard Application**: Apply FirebaseAuthGuard + WorkspaceGuard to OAuth endpoints. Webhook endpoint uses signature verification only.

9. **Frontend Service Injection**: Use useServices() hook pattern for GitHubService dependency injection. No direct imports in components.

10. **Testing Requirements**: Unit tests for token encryption/decryption, webhook signature verification. Integration tests for OAuth flow with mock GitHub responses.
  </constraints>

  <interfaces>
    <interface>
      <name>POST /api/github/oauth/authorize</name>
      <kind>REST endpoint</kind>
      <signature>
Request: No body
Response: { oauthUrl: string, state: string }
Guards: FirebaseAuthGuard, WorkspaceGuard
      </signature>
      <path>backend/src/github/presentation/controllers/github-oauth.controller.ts</path>
    </interface>

    <interface>
      <name>GET /api/github/oauth/callback</name>
      <kind>REST endpoint</kind>
      <signature>
Query: { code: string, state: string }
Response: { success: boolean, message: string }
Guards: None (public endpoint, user redirected from GitHub)
      </signature>
      <path>backend/src/github/presentation/controllers/github-oauth.controller.ts</path>
    </interface>

    <interface>
      <name>GET /api/github/repositories</name>
      <kind>REST endpoint</kind>
      <signature>
Request: No body
Response: { repositories: Array<{ id: string, fullName: string, visibility: string, updatedAt: string }> }
Guards: FirebaseAuthGuard, WorkspaceGuard
      </signature>
      <path>backend/src/github/presentation/controllers/github-oauth.controller.ts</path>
    </interface>

    <interface>
      <name>POST /api/github/repositories/select</name>
      <kind>REST endpoint</kind>
      <signature>
Request: { repositoryIds: string[] }
Response: { success: boolean, selectedCount: number }
Guards: FirebaseAuthGuard, WorkspaceGuard
      </signature>
      <path>backend/src/github/presentation/controllers/github-oauth.controller.ts</path>
    </interface>

    <interface>
      <name>POST /api/github/disconnect</name>
      <kind>REST endpoint</kind>
      <signature>
Request: No body
Response: { success: boolean, message: string }
Guards: FirebaseAuthGuard, WorkspaceGuard
      </signature>
      <path>backend/src/github/presentation/controllers/github-oauth.controller.ts</path>
    </interface>

    <interface>
      <name>POST /api/webhooks/github</name>
      <kind>Webhook endpoint</kind>
      <signature>
Headers: { x-hub-signature-256: string, x-github-event: string }
Request: GitHub webhook payload (push or pull_request event)
Response: { received: boolean }
Guards: None (signature verification only)
      </signature>
      <path>backend/src/github/infrastructure/webhooks/github-webhook.handler.ts</path>
    </interface>

    <interface>
      <name>GitHubIntegrationRepository</name>
      <kind>Repository interface</kind>
      <signature>
save(integration: GitHubIntegration): Promise<void>
findByWorkspace(workspaceId: string): Promise<GitHubIntegration | null>
delete(workspaceId: string): Promise<void>
      </signature>
      <path>backend/src/github/domain/GitHubIntegrationRepository.ts</path>
    </interface>

    <interface>
      <name>GitHubTokenService</name>
      <kind>Application service</kind>
      <signature>
exchangeCodeForToken(code: string, state: string): Promise<GitHubToken>
refreshToken(refreshToken: string): Promise<GitHubToken>
revokeToken(workspaceId: string): Promise<void>
encryptToken(token: string): string
decryptToken(encrypted: string): string
      </signature>
      <path>backend/src/github/application/services/github-token.service.ts</path>
    </interface>
  </interfaces>

  <tests>
    <standards>
Co-located tests (AEC.spec.ts next to AEC.ts). Jest testing framework. Unit tests for business logic, integration tests for API endpoints. Mock external dependencies (Octokit, Firebase Admin). Test coverage for critical paths (OAuth flow, token encryption, webhook verification).
    </standards>

    <locations>
backend/src/**/*.spec.ts
client/src/**/*.test.tsx
    </locations>

    <ideas>
**Unit Tests:**
- GitHubTokenService.encryptToken() / decryptToken() with test vectors
- GitHubTokenService.exchangeCodeForToken() with mocked Octokit response
- Webhook signature verification with valid and invalid signatures
- OAuth state parameter generation and validation

**Integration Tests:**
- POST /api/github/oauth/authorize returns valid OAuth URL
- GET /api/github/oauth/callback exchanges code for token, stores in Firestore
- GET /api/github/repositories returns user repos (mocked Octokit)
- POST /api/webhooks/github with valid signature triggers index update
- POST /api/github/disconnect revokes token and clears integration

**Frontend Tests:**
- GitHubIntegration component renders Connect button when not connected
- GitHubIntegration component renders repository list when connected
- RepositorySelector shows dropdown when GitHub connected
- Settings store actions (loadGitHubStatus, selectRepositories, disconnectGitHub)
    </ideas>
  </tests>
</story-context>
