<story-context id=".bmad/bmm/workflows/4-implementation/story-context/template" v="1.0">
  <metadata>
    <epicId>4</epicId>
    <storyId>4.5</storyId>
    <title>Effort Estimation - Multi-Factor Calculation</title>
    <status>drafted</status>
    <generatedAt>2026-02-02T19:59:45.123Z</generatedAt>
    <generator>BMAD Story Context Workflow</generator>
    <sourceStoryPath>docs/sprint-artifacts/4-5-effort-estimation-multi-factor-calculation.md</sourceStoryPath>
  </metadata>

  <story>
    <asA>Product Manager</asA>
    <iWant>accurate effort estimates based on code complexity and similar tickets</iWant>
    <soThat>I can plan sprints realistically</soThat>
    <tasks>
      - Verify Estimate value object exists (already in domain)
      - Create IEstimationEngine interface
      - Implement EstimationEngineService
      - Create EstimateEffortUseCase
      - Implement module counting logic
      - Implement API change detection
      - Implement DB migration detection
      - Implement auth change detection
      - Implement similar tickets query
      - Calculate confidence based on historical data
      - Identify top 3 effort drivers
      - Integrate with generation orchestrator (step 8)
      - Write unit tests
      - Write integration tests
    </tasks>
  </story>

  <acceptanceCriteria>
    AC1: System calculates effort based on modules touched (files/modules affected)
    AC2: System considers API changes (new endpoints, modified schemas)
    AC3: System factors in DB migrations (schema changes detected)
    AC4: System accounts for auth complexity (permissions, roles changes)
    AC5: System queries historical tickets with similar scope
    AC6: Estimation output includes min-max range (e.g., "4-8 hours")
    AC7: Estimation includes confidence level (Low/Medium/High)
    AC8: Estimation includes top 3 drivers
    AC9: Estimate stored in AEC.estimate field
    AC10: Base effort is 2 hours minimum
    AC11: +1-2 hours per module touched
    AC12: +2-4 hours for API changes
    AC13: +3-6 hours for DB migrations
    AC14: +2-3 hours for auth changes
    AC15: High confidence (5+ historical tickets) narrows range
    AC16: Low confidence (0-1 historical tickets) widens range to 4-12 hours
    AC17: UI displays estimate badge with confidence
  </acceptanceCriteria>

  <artifacts>
    <docs>
      <doc>
        <path>docs/architecture.md</path>
        <title>System Architecture</title>
        <section>Mastra Boundaries</section>
        <snippet>Estimation uses deterministic NestJS services (no LLM). Rule-based calculation for MVP. Epic 4: EstimationEngine is deterministic service.</snippet>
      </doc>
      <doc>
        <path>docs/prd.md</path>
        <title>Product Requirements Document</title>
        <section>FR6 - Effort Estimation</section>
        <snippet>System provides effort estimates based on code complexity, API changes, DB migrations, and historical tickets. Range with confidence level.</snippet>
      </doc>
      <doc>
        <path>docs/epics.md</path>
        <title>Epic Breakdown</title>
        <section>Story 4.5 Details</section>
        <snippet>Final story in Epic 4. Covers FR6. Prerequisites: Stories 4.2 (indexing), 4.3 (API sync), 3.1 (validation) all completed.</snippet>
      </doc>
    </docs>

    <code>
      <artifact>
        <path>backend/src/tickets/domain/value-objects/Estimate.ts</path>
        <kind>value-object</kind>
        <symbol>Estimate</symbol>
        <lines>1-6</lines>
        <reason>Already exists - interface with min, max, confidence, drivers fields</reason>
      </artifact>
      <artifact>
        <path>backend/src/tickets/domain/aec/AEC.ts</path>
        <kind>entity</kind>
        <symbol>AEC</symbol>
        <reason>AEC entity has _estimate field - use setEstimate() method to update</reason>
      </artifact>
      <artifact>
        <path>backend/src/tickets/application/services/GenerationOrchestrator.ts</path>
        <kind>service</kind>
        <symbol>GenerationOrchestrator</symbol>
        <reason>Orchestrates 8-step generation - integrate estimation at step 8</reason>
      </artifact>
      <artifact>
        <path>backend/src/indexing/domain/Index.ts</path>
        <kind>entity</kind>
        <symbol>Index</symbol>
        <reason>Code index entity - use to count files/modules touched</reason>
      </artifact>
      <artifact>
        <path>backend/src/indexing/application/services/index-query.service.ts</path>
        <kind>service</kind>
        <symbol>IndexQueryService</symbol>
        <reason>Query service for code index - use to detect changes</reason>
      </artifact>
      <artifact>
        <path>backend/src/indexing/domain/entities/ApiSpec.ts</path>
        <kind>entity</kind>
        <symbol>ApiSpec</symbol>
        <reason>API spec entity - use to detect API changes</reason>
      </artifact>
    </code>

    <dependencies>
      <node>
        <package name="@nestjs/common" version="^10.3.0" dev="false" notes="EXISTING - NestJS core" />
        <package name="firebase-admin" version="^12.0.0" dev="false" notes="EXISTING - Firestore for historical tickets" />
      </node>
    </dependencies>
  </artifacts>

  <constraints>
    - Follow Clean Architecture: domain → application → infrastructure
    - Estimate value object ALREADY EXISTS - reuse it
    - IEstimationEngine interface goes in application/services/
    - EstimationEngineService implementation in infrastructure/services/
    - EstimateEffortUseCase in application/use-cases/
    - Estimation is DETERMINISTIC (no LLM, no ML for MVP)
    - Rule-based calculation only
    - Integrate with GenerationOrchestrator at step 8
    - Query historical tickets from Firestore efficiently
    - Use existing IndexQueryService for code analysis
    - Use existing ApiSpecIndexer for API change detection
    - Detection heuristics: migration files = "migration" in filename, auth files = "auth" in path
    - All tests must pass 100%
    - TypeScript strict mode
    - Follow existing naming conventions
  </constraints>

  <interfaces>
    <interface>
      <name>IEstimationEngine</name>
      <kind>TypeScript Interface</kind>
      <signature>
        interface IEstimationEngine {
          estimateEffort(params: EstimationParams): Promise&lt;Estimate&gt;;
        }
        
        interface EstimationParams {
          workspaceId: string;
          repositoryName: string;
          ticketType: TicketType;
          repoPaths: string[];
          hasApiChanges: boolean;
          hasDatabaseChanges: boolean;
          hasAuthChanges: boolean;
        }
      </signature>
      <path>backend/src/tickets/application/services/estimation-engine.interface.ts</path>
    </interface>
    <interface>
      <name>EstimateEffortUseCase</name>
      <kind>TypeScript Class</kind>
      <signature>
        class EstimateEffortUseCase {
          async execute(aecId: string): Promise&lt;Estimate&gt;;
        }
      </signature>
      <path>backend/src/tickets/application/use-cases/estimate-effort.use-case.ts</path>
    </interface>
    <interface>
      <name>Estimate (existing)</name>
      <kind>TypeScript Interface</kind>
      <signature>
        interface Estimate {
          min: number;
          max: number;
          confidence: 'low' | 'medium' | 'high';
          drivers: string[];
        }
      </signature>
      <path>backend/src/tickets/domain/value-objects/Estimate.ts</path>
    </interface>
  </interfaces>

  <tests>
    <standards>
      Follow existing testing patterns. Use Jest for unit tests, NestJS testing utilities for integration tests. Mock external dependencies (Firestore, IndexQueryService). Test files colocated with source in __tests__ directories or .spec.ts files. Aim for 100% coverage of estimation logic. Test all calculation branches (with/without API changes, different confidence levels).
    </standards>

    <locations>
      backend/src/tickets/infrastructure/services/__tests__/
      backend/src/tickets/application/use-cases/__tests__/
    </locations>

    <ideas>
      <test ac="AC1" desc="Counts modules from repoPaths" />
      <test ac="AC2" desc="Detects API changes from hasApiChanges flag" />
      <test ac="AC3" desc="Detects DB migrations from hasDatabase Changes flag" />
      <test ac="AC4" desc="Detects auth changes from hasAuthChanges flag" />
      <test ac="AC5" desc="Queries historical tickets by type and repo" />
      <test ac="AC6" desc="Returns min-max range" />
      <test ac="AC7" desc="Returns confidence level (low/medium/high)" />
      <test ac="AC8" desc="Returns top 3 drivers" />
      <test ac="AC9" desc="Stores estimate in AEC" />
      <test ac="AC10" desc="Base effort is 2 hours" />
      <test ac="AC11" desc="Adds 1-2 hours per module" />
      <test ac="AC12" desc="Adds 2-4 hours for API changes" />
      <test ac="AC13" desc="Adds 3-6 hours for DB migrations" />
      <test ac="AC14" desc="Adds 2-3 hours for auth changes" />
      <test ac="AC15" desc="High confidence (5+ tickets) narrows range" />
      <test ac="AC16" desc="Low confidence widens range to 4-12 hours" />
      <test ac="AC17" desc="Medium confidence (2-4 tickets) keeps calculated range" />
    </ideas>
  </tests>
</story-context>
