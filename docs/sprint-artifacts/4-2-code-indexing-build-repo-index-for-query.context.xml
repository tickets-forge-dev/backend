<story-context id=".bmad/bmm/workflows/4-implementation/story-context/template" v="1.0">
  <metadata>
    <epicId>4</epicId>
    <storyId>2</storyId>
    <title>Code Indexing - Build Repo Index for Query</title>
    <status>drafted</status>
    <generatedAt>2026-02-02</generatedAt>
    <generator>BMAD Story Context Workflow</generator>
    <sourceStoryPath>docs/sprint-artifacts/4-2-code-indexing-build-repo-index-for-query.md</sourceStoryPath>
  </metadata>

  <story>
    <asA>backend system</asA>
    <iWant>to index GitHub repositories into a queryable structure</iWant>
    <soThat>ticket generation can find relevant code modules quickly</soThat>
    <tasks>
- Task 1: Webhook Handler Implementation (AC: #4 - Deferred from Story 4.1)
- Task 2: Repository Indexing Service (AC: #1, #2) - Clone, parse, extract metadata
- Task 3: File Parser & Metadata Extractor (AC: #1) - TypeScript/JavaScript/Python/Go parsers
- Task 4: Index Domain Model & Repository (AC: #2) - Domain entities and Firestore persistence
- Task 5: Indexing Job Queue (AC: #3) - Bull queue with progress tracking
- Task 6: Index Query Service (AC: #5) - Keyword search interface for ticket generation
- Task 7: Indexing Controller & DTOs (AC: #3, #5) - REST endpoints
- Task 8: Frontend Indexing Status UI (AC: #3) - Progress display in Settings
- Task 9: Frontend Indexing Service (AC: #3) - API client methods
- Task 10: Settings Store Updates (AC: #3) - Zustand state management
- Task 11: Write Tests (AC: #1-6) - Unit and integration tests
    </tasks>
  </story>

  <acceptanceCriteria>
1. **Repository Cloning & File Parsing** - Shallow clone, parse file tree, extract exports/imports/functions
2. **Index Storage in Firestore** - `/workspaces/{wid}/indexes/{indexId}` with repoName, commitSha, files[]
3. **Indexing Progress Tracking** - UI shows progress, async job, notifications
4. **Webhook-Triggered Re-indexing** - GitHub webhooks trigger incremental re-index, signature verification
5. **Index Query Interface** - `findModulesByIntent()` with keyword/semantic search
6. **Error Handling & Edge Cases** - Large repos pagination, binary files skipped, retry logic
7. **Resource Limits & Cost Control** - Max repo size 2GB, max files 50k, timeouts enforced
8. **Security Hardening** - Rate limiting, ownership validation, path sanitization, malicious file detection
9. **Observability & Monitoring** - Duration tracking, structured logging, health checks, metrics
10. **Failure Recovery & Resilience** - Exponential backoff retry, dead letter queue, checkpointing, resume
  </acceptanceCriteria>

  <artifacts>
    <docs>
      <doc>
        <path>docs/architecture.md</path>
        <title>Architecture: Executable Tickets</title>
        <section>Clean Architecture Pattern</section>
        <snippet>Feature-based modules with internal presentation/application/domain/infrastructure layers. Indexing module: Domain (Index entity, FileMetadata VO), Application (RepoIndexerService, IndexQueryService), Presentation (IndexingController, WebhookHandler), Infrastructure (Firestore repo, Bull queue).</snippet>
      </doc>
      <doc>
        <path>docs/architecture.md</path>
        <title>Architecture: Executable Tickets</title>
        <section>Background Jobs</section>
        <snippet>Use NestJS Bull Queue (Redis-backed). Jobs have progress tracking, retry logic (3 attempts with exponential backoff), job status stored in Firestore. Queue: IndexRepositoryJob with payload { workspaceId, repoName, commitSha, indexId }.</snippet>
      </doc>
      <doc>
        <path>docs/architecture.md</path>
        <title>Architecture: Executable Tickets</title>
        <section>Firestore Collections</section>
        <snippet>/workspaces/{workspaceId}/indexes/{indexId} stores: repoName, commitSha, files[], status, filesIndexed, totalFiles, createdAt. Each file: { path, language, exports[], imports[], summary, loc }.</snippet>
      </doc>
      <doc>
        <path>docs/prd_epic4_additions.md</path>
        <title>Epic 4 Additions to PRD</title>
        <section>Story 4.2 - Code Indexing</section>
        <snippet>Depends on Stories 4.0 (branch selection) and 4.1 (GitHub OAuth). Indexes files from selected branch. Builds searchable index of modules and dependencies. Webhooks trigger re-indexing on code changes.</snippet>
      </doc>
      <doc>
        <path>docs/epics.md</path>
        <title>forge - Epic Breakdown</title>
        <section>Story 4.2 - Code Indexing</section>
        <snippet>System clones repo (shallow), parses file structure, extracts metadata (path, language, exports, imports, functions), builds queryable index. Stored in Firestore. Indexing job runs async with progress tracking. Query interface: findModulesByIntent(intent, indexId). Incremental re-index on webhook events.</snippet>
      </doc>
      <doc>
        <path>docs/sprint-artifacts/4-1-github-app-integration-read-only-repo-access.md</path>
        <title>Story 4.1: GitHub App Integration</title>
        <section>Completion Notes</section>
        <snippet>GitHub OAuth complete. Token storage and encryption working. Repository selection persistence implemented. Webhook handler deferred to Story 4.2. Services available: GitHubApiService (API calls), GitHubTokenService (token decryption), GitHubIntegrationRepository (load integrations).</snippet>
      </doc>
    </docs>

    <code>
      <artifact>
        <path>backend/src/shared/infrastructure/github/github-api.service.ts</path>
        <kind>service</kind>
        <symbol>GitHubApiService</symbol>
        <lines>1-234</lines>
        <reason>Existing GitHub API service using Octokit. Has getRepository(), listBranches(), getBranchHead(). Reuse for GitHub API calls during indexing (get repo metadata, clone URL).</reason>
      </artifact>
      <artifact>
        <path>backend/src/github/application/services/github-token.service.ts</path>
        <kind>service</kind>
        <symbol>GitHubTokenService</symbol>
        <lines>1-180</lines>
        <reason>Token encryption/decryption service. Use decryptToken() to get access token for authenticated Git clone and GitHub API calls during indexing.</reason>
      </artifact>
      <artifact>
        <path>backend/src/github/infrastructure/persistence/firestore-github-integration.repository.ts</path>
        <kind>repository</kind>
        <symbol>FirestoreGitHubIntegrationRepository</symbol>
        <lines>1-150</lines>
        <reason>Loads GitHub integration for workspace. Use findByWorkspaceId() to get access token and selected repositories before indexing.</reason>
      </artifact>
      <artifact>
        <path>backend/src/github/domain/GitHubIntegration.ts</path>
        <kind>entity</kind>
        <symbol>GitHubIntegration</symbol>
        <lines>1-80</lines>
        <reason>Domain entity for GitHub integration. Contains selectedRepositories property (GitHubRepository[]). Use to get list of repos to index.</reason>
      </artifact>
      <artifact>
        <path>backend/src/github/domain/GitHubRepository.ts</path>
        <kind>entity</kind>
        <symbol>GitHubRepository</symbol>
        <lines>1-60</lines>
        <reason>Domain entity for repository. Has id, fullName, name, owner, defaultBranch properties. Use as reference for repository metadata.</reason>
      </artifact>
      <artifact>
        <path>backend/src/shared/presentation/guards/FirebaseAuthGuard.ts</path>
        <kind>guard</kind>
        <symbol>FirebaseAuthGuard</symbol>
        <lines>1-45</lines>
        <reason>Authentication guard for controllers. Apply to indexing endpoints (except webhook which uses signature verification).</reason>
      </artifact>
      <artifact>
        <path>backend/src/shared/presentation/guards/WorkspaceGuard.ts</path>
        <kind>guard</kind>
        <symbol>WorkspaceGuard</symbol>
        <lines>1-50</lines>
        <reason>Workspace isolation guard. Apply to indexing endpoints. Extracts workspaceId from request via @WorkspaceId() decorator.</reason>
      </artifact>
      <artifact>
        <path>client/src/settings/components/GitHubIntegration.tsx</path>
        <kind>component</kind>
        <symbol>GitHubIntegration</symbol>
        <lines>1-280</lines>
        <reason>Settings UI for GitHub connection. Extend with indexing UI (add "Index Selected Repos" button, progress display, indexed repos list).</reason>
      </artifact>
      <artifact>
        <path>client/src/services/github.service.ts</path>
        <kind>service</kind>
        <symbol>githubService</symbol>
        <lines>1-150</lines>
        <reason>Frontend GitHub service. Extend with indexing methods: startIndexing(), getIndexingStatus(), queryIndex().</reason>
      </artifact>
      <artifact>
        <path>client/src/stores/settings.store.ts</path>
        <kind>store</kind>
        <symbol>useSettingsStore</symbol>
        <lines>1-200</lines>
        <reason>Zustand settings store. Extend with indexing state (indexingJobs, indexedRepositories) and actions (startIndexing, pollIndexingStatus).</reason>
      </artifact>
    </code>

    <dependencies>
      <package>
        <name>simple-git</name>
        <version>latest</version>
        <purpose>Git operations - clone repository, get commit info</purpose>
        <scope>backend</scope>
      </package>
      <package>
        <name>@bull-board/nestjs</name>
        <version>latest</version>
        <purpose>Bull queue monitoring UI (optional, for debugging)</purpose>
        <scope>backend</scope>
      </package>
      <package>
        <name>tree-sitter</name>
        <version>^0.21.0</version>
        <purpose>Universal parser library supporting 40+ languages with consistent API</purpose>
        <scope>backend</scope>
      </package>
      <package>
        <name>tree-sitter-javascript</name>
        <version>^0.21.0</version>
        <purpose>JavaScript grammar for Tree-sitter parser</purpose>
        <scope>backend</scope>
      </package>
      <package>
        <name>tree-sitter-typescript</name>
        <version>^0.21.0</version>
        <purpose>TypeScript grammar for Tree-sitter parser</purpose>
        <scope>backend</scope>
      </package>
      <package>
        <name>tree-sitter-python</name>
        <version>^0.21.0</version>
        <purpose>Python grammar for Tree-sitter parser</purpose>
        <scope>backend</scope>
      </package>
      <package>
        <name>tree-sitter-go</name>
        <version>^0.21.0</version>
        <purpose>Go grammar for Tree-sitter parser</purpose>
        <scope>backend</scope>
      </package>
      <package>
        <name>tree-sitter-java</name>
        <version>^0.21.0</version>
        <purpose>Java grammar for Tree-sitter parser</purpose>
        <scope>backend</scope>
      </package>
      <package>
        <name>tree-sitter-rust</name>
        <version>^0.21.0</version>
        <purpose>Rust grammar for Tree-sitter parser</purpose>
        <scope>backend</scope>
      </package>
      <package>
        <name>tree-sitter-ruby</name>
        <version>^0.21.0</version>
        <purpose>Ruby grammar for Tree-sitter parser</purpose>
        <scope>backend</scope>
      </package>
      <package>
        <name>tree-sitter-c-sharp</name>
        <version>^0.21.0</version>
        <purpose>C# grammar for Tree-sitter parser</purpose>
        <scope>backend</scope>
      </package>
      <package>
        <name>@nestjs/bull</name>
        <version>latest</version>
        <purpose>Bull queue integration for async indexing jobs</purpose>
        <scope>backend</scope>
      </package>
      <package>
        <name>bull</name>
        <version>latest</version>
        <purpose>Redis-backed job queue for async processing</purpose>
        <scope>backend</scope>
      </package>
      <package>
        <name>@nestjs/throttler</name>
        <version>latest</version>
        <purpose>Rate limiting for webhook endpoint</purpose>
        <scope>backend</scope>
      </package>
      <package>
        <name>@nestjs/terminus</name>
        <version>latest</version>
        <purpose>Health check endpoints</purpose>
        <scope>backend</scope>
      </package>
    </dependencies>

    <interfaces>
      <interface>
        <name>RepoIndexerService</name>
        <methods>
          <method>indexRepository(workspaceId: string, repoId: number, commitSha: string): Promise&lt;string&gt;</method>
          <method>reindexRepository(workspaceId: string, indexId: string): Promise&lt;void&gt;</method>
        </methods>
        <purpose>Orchestrates repository cloning, file parsing, and index storage</purpose>
      </interface>
      <interface>
        <name>FileParserService</name>
        <methods>
          <method>parseFile(filePath: string, language: string): Promise&lt;FileMetadata&gt;</method>
          <method>detectLanguage(filePath: string): string</method>
          <method>extractExports(content: string, language: string): string[]</method>
          <method>extractImports(content: string, language: string): string[]</method>
        </methods>
        <purpose>Language-specific file parsing to extract code structure</purpose>
      </interface>
      <interface>
        <name>IndexQueryService</name>
        <methods>
          <method>findModulesByIntent(intent: string, indexId: string): Promise&lt;Module[]&gt;</method>
          <method>findFilesByPath(pattern: string, indexId: string): Promise&lt;FileMetadata[]&gt;</method>
          <method>getIndexStats(indexId: string): Promise&lt;IndexStats&gt;</method>
        </methods>
        <purpose>Query indexed code for ticket generation and analysis</purpose>
      </interface>
      <interface>
        <name>IndexRepository</name>
        <methods>
          <method>save(index: Index): Promise&lt;void&gt;</method>
          <method>findById(indexId: string): Promise&lt;Index | null&gt;</method>
          <method>findByWorkspaceAndRepo(workspaceId: string, repoId: number): Promise&lt;Index[]&gt;</method>
          <method>updateProgress(indexId: string, progress: number, total: number): Promise&lt;void&gt;</method>
        </methods>
        <purpose>Persistence layer for index data in Firestore</purpose>
      </interface>
      <interface>
        <name>GitHubWebhookHandler</name>
        <methods>
          <method>handlePushEvent(payload: PushPayload): Promise&lt;void&gt;</method>
          <method>handlePullRequestEvent(payload: PRPayload): Promise&lt;void&gt;</method>
          <method>verifySignature(signature: string, body: string): boolean</method>
        </methods>
        <purpose>Process GitHub webhook events for automatic re-indexing</purpose>
      </interface>
    </interfaces>

    <constraints>
      <constraint>
        <type>performance</type>
        <description>Indexing large repos (&gt;10k files) must use pagination and progress tracking. Avoid loading entire file tree into memory.</description>
      </constraint>
      <constraint>
        <type>security</type>
        <description>Webhook signature must be verified using HMAC-SHA256. Use GITHUB_WEBHOOK_SECRET from env. Reject requests with invalid signatures.</description>
      </constraint>
      <constraint>
        <type>architecture</type>
        <description>Indexing must be async (Bull queue). UI polls for progress. Do not block HTTP requests waiting for indexing to complete.</description>
      </constraint>
      <constraint>
        <type>storage</type>
        <description>Cloned repositories stored in OS temp directory. Clean up after indexing completes. Do not persist cloned repos.</description>
      </constraint>
      <constraint>
        <type>scalability</type>
        <description>Redis required for Bull queue. Ensure Redis is running and configured in app.module.ts before implementing.</description>
      </constraint>
      <constraint>
        <type>domain</type>
        <description>Index entity and FileMetadata value object must have NO framework dependencies (Clean Architecture). No NestJS, Firestore, or Bull imports in domain layer.</description>
      </constraint>
      <constraint>
        <type>resource-limits</type>
        <description>Max repository size: 2GB. Max files per index: 50,000. Clone timeout: 5 minutes. Parse timeout per file: 10 seconds. Workspace storage quota: 10 repos. Enforce limits before operations, fail gracefully with clear errors.</description>
      </constraint>
      <constraint>
        <type>security</type>
        <description>Webhook rate limiting: 100 req/min per repo. Validate repository ownership via GitHub token. Sanitize all file paths. Blacklist malicious extensions (.exe, .dll, .so, .dylib). Isolate clone operations in separate temp dirs. Auto-cleanup orphaned directories after 1 hour.</description>
      </constraint>
      <constraint>
        <type>observability</type>
        <description>Log all operations with structured context (workspaceId, repoId, indexId, jobId). Track indexing duration (p50, p95, p99). Count Firestore operations. Expose queue metrics. Provide health check endpoint. Store indexing metadata (duration, filesProcessed, errors).</description>
      </constraint>
      <constraint>
        <type>resilience</type>
        <description>Retry failed jobs 3 times with exponential backoff (1s, 5s, 15s). Move to dead letter queue after retries. Save checkpoints every 1000 files. Resume from checkpoint on retry. Isolate Tree-sitter crashes per file. Store error details in index. Provide manual re-trigger.</description>
      </constraint>
    </constraints>

    <tests>
      <testStrategy>
        <layer>unit</layer>
        <coverage>
          <item>FileParserService.parseFile() - extract exports/imports using Tree-sitter for TypeScript/JavaScript/Python/Go/Java/Rust/Ruby/C#</item>
          <item>FileParserService.detectLanguage() - correct language detection and Tree-sitter grammar mapping from file extension</item>
          <item>FileParserService.extractSymbols() - Tree-sitter query execution for function/class/export extraction</item>
          <item>FileParserService fallback - metadata-only extraction for unsupported languages</item>
          <item>GitHubWebhookHandler.verifySignature() - HMAC-SHA256 validation</item>
          <item>IndexQueryService.findModulesByIntent() - keyword matching and relevance ranking</item>
          <item>Index domain entity - business logic methods (addFile, markComplete, etc.)</item>
        </coverage>
      </testStrategy>
      <testStrategy>
        <layer>integration</layer>
        <coverage>
          <item>Full indexing workflow - POST /api/indexing/start → job queued → repo cloned → files parsed → index stored</item>
          <item>Webhook triggers re-index - POST /api/webhooks/github → signature verified → job queued</item>
          <item>Progress polling - GET /api/indexing/status/:indexId returns current progress</item>
          <item>Query indexed code - POST /api/indexing/query returns relevant modules</item>
        </coverage>
      </testStrategy>
      <testFiles>
        <file>backend/src/indexing/application/services/__tests__/repo-indexer.service.spec.ts</file>
        <file>backend/src/indexing/application/services/__tests__/file-parser.service.spec.ts</file>
        <file>backend/src/indexing/application/services/__tests__/index-query.service.spec.ts</file>
        <file>backend/src/github/infrastructure/webhooks/__tests__/github-webhook.handler.spec.ts</file>
        <file>backend/src/indexing/domain/__tests__/Index.spec.ts</file>
        <file>backend/src/indexing/domain/__tests__/FileMetadata.spec.ts</file>
        <file>backend/src/indexing/__tests__/indexing.integration.spec.ts</file>
      </testFiles>
    </tests>

    <implementation_notes>
      <note priority="critical">
        <topic>Webhook Handler Completion</topic>
        <detail>Story 4.1 deferred webhook implementation to this story. Must implement github-webhook.handler.ts with signature verification before indexing can be triggered by code changes.</detail>
      </note>
      <note priority="high">
        <topic>Redis Dependency</topic>
        <detail>Bull queue requires Redis. Ensure Redis is installed and running. Add BullModule configuration to app.module.ts with Redis connection string from environment variables.</detail>
      </note>
      <note priority="high">
        <topic>Tree-sitter Universal Parsing</topic>
        <detail>Use Tree-sitter for multi-language code parsing. Install language grammars as npm packages (tree-sitter-javascript, tree-sitter-python, etc). Tree-sitter provides consistent API across 40+ languages. Use queries like (function_declaration name: (identifier) @name) to extract symbols. Fallback to metadata-only extraction (path, size, LOC) for unsupported languages. Production-proven: used by GitHub, Atom, Neovim.</detail>
      </note>
      <note priority="medium">
        <topic>Temporary Storage Cleanup</topic>
        <detail>Cloned repos stored in OS.tmpdir(). Implement cleanup in finally block or job completion handler. Use unique directory per job to avoid conflicts.</detail>
      </note>
      <note priority="medium">
        <topic>Query Interface Evolution</topic>
        <detail>Initial implementation uses keyword matching. Can upgrade to semantic search with embeddings (OpenAI/Voyage) in future stories. Design query interface to support both strategies.</detail>
      </note>
      <note priority="low">
        <topic>Indexing Optimization</topic>
        <detail>Incremental re-indexing only parses changed files (use git diff). Full re-index recreates entire index. Track last indexed commitSha to determine strategy.</detail>
      </note>
      <note priority="high">
        <topic>Production Resource Limits</topic>
        <detail>Enforce MAX_REPO_SIZE_MB (2GB), MAX_FILES_PER_INDEX (50k), CLONE_TIMEOUT_MS (5min), PARSE_TIMEOUT_MS (10s) from environment. Check repo size via GitHub API before cloning. Cancel jobs exceeding limits with clear error. Track workspace storage quota.</detail>
      </note>
      <note priority="high">
        <topic>Security Hardening</topic>
        <detail>Use @nestjs/throttler for webhook rate limiting. Validate repo ownership: check user has access via GitHub token before indexing. Sanitize paths with path.normalize() and reject ../ traversal. Blacklist extensions: .exe, .dll, .so, .dylib, .app, .bin. Use unique temp dir per job: /tmp/indexing-{jobId}/. Auto-cleanup with cron or job completion hook.</detail>
      </note>
      <note priority="high">
        <topic>Observability & Health Checks</topic>
        <detail>Use @nestjs/terminus for health endpoint. Check Redis connection, Firestore availability, queue size. Log with Pino including correlation IDs. Track metrics: indexing_duration_ms, files_processed_count, parse_errors_count, queue_size. Store in index: indexDurationMs, filesIndexed, filesSkipped, parseErrors, repoSizeMB.</detail>
      </note>
      <note priority="medium">
        <topic>Checkpointing Strategy</topic>
        <detail>Save checkpoint every 1000 files or 30 seconds (whichever comes first). Store checkpoint: {indexId, lastProcessedPath, filesProcessed, timestamp}. On job retry, load checkpoint and skip already-processed files. Clean up checkpoints after successful completion.</detail>
      </note>
    </implementation_notes>
  </artifacts>
</story-context>
