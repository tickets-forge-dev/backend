<story-context id=".bmad/bmm/workflows/4-implementation/story-context/template" v="1.0">
  <metadata>
    <epicId>2</epicId>
    <storyId>1</storyId>
    <title>Ticket Creation UI - Minimal Input Form</title>
    <status>drafted</status>
    <generatedAt>2026-01-31</generatedAt>
    <generator>BMAD Story Context Workflow</generator>
    <sourceStoryPath>docs/sprint-artifacts/2-1-ticket-creation-ui-minimal-input-form.md</sourceStoryPath>
  </metadata>

  <story>
    <asA>Product Manager</asA>
    <iWant>to create a new ticket by entering title and optional description</iWant>
    <soThat>I can start the ticket generation process with minimal effort</soThat>
    <tasks>
      - Task 1: Create Zustand store for tickets (AC: #4)
      - Task 2: Create ticket service for API calls (AC: #4)
      - Task 3: Update existing CreateTicketForm component (AC: #2, #3, #6)
      - Task 4: Implement navigation and cancel (AC: #1, #5)
      - Task 5: Add error handling UI (AC: #7)
      - Task 6: Write tests
    </tasks>
  </story>

  <acceptanceCriteria>
    1. Ticket Creation Entry Point - "New Ticket" button on tickets list navigates to create form

    2. Minimal Input Form Display - Form shows title input (required), description textarea (optional), "Generate Ticket" button (disabled initially), "Cancel" ghost button, centered max-width 640px

    3. Form Validation - Title <3 chars keeps button disabled, title ≥3 chars enables button

    4. Submit Ticket Creation - POST /api/tickets with title/description, loading state during API call, navigate to ticket detail on success

    5. Cancel Action - Cancel button navigates back to /tickets, no API call made

    6. Linear Minimalism Compliance - No unnecessary borders, generous whitespace, subtle focus states, uses design tokens, max-width 640px

    7. Error Handling - Display error messages from API, retry button, preserve form data on error
  </acceptanceCriteria>

  <artifacts>
    <docs>
      <doc>
        <path>docs/sprint-artifacts/tech-spec-epic-2.md</path>
        <title>Epic 2 Technical Specification</title>
        <section>Story 2.1 Implementation</section>
        <snippet>Story 2.1 creates minimal ticket creation UI with Zustand store (tickets.store.ts), API service (ticket.service.ts), form validation (title ≥3 chars), and integration with POST /api/tickets endpoint. Uses shadcn/ui components from Epic 1, follows dependency injection pattern via useServices() hook.</snippet>
      </doc>
      <doc>
        <path>docs/prd.md</path>
        <title>Product Requirements Document</title>
        <section>Ticket Creation Flow</section>
        <snippet>PM-first experience: minimal input (title + optional description), no technical fields required, transparent 8-step generation, <60 second total time, builds trust through visibility.</snippet>
      </doc>
      <doc>
        <path>docs/ux.md</path>
        <title>UX Design Specification</title>
        <section>Create Ticket Screen</section>
        <snippet>UX North Star: PM creates trusted ticket in <60 seconds feeling calm, in control, confident. Progressive disclosure, explain every automation, ask only what changes execution. Anti-patterns: multi-step wizards, dense forms, required technical fields.</snippet>
      </doc>
      <doc>
        <path>docs/architecture.md</path>
        <title>Architecture Document</title>
        <section>Frontend Communication Patterns</section>
        <snippet>Frontend → Backend via REST API with Bearer token. Request format: JSON with Zod-validated DTOs. Response: Direct JSON (no envelope). Shared types via @repo/shared-types. Zustand stores with service injection pattern (useServices() hook). Business logic in store actions, not components.</snippet>
      </doc>
      <doc>
        <path>CLAUDE.md</path>
        <title>Project Development Standards</title>
        <section>Client Architecture Rules</section>
        <snippet>MANDATORY: use dependency injection system via useServices() hook for all services. Use Zustand for state management with lazy service access. UI renders state and triggers actions only - NO business logic in components. Always handle loading, error, and empty states.</snippet>
      </doc>
    </docs>

    <code>
      <file>
        <path>client/app/(main)/tickets/create/page.tsx</path>
        <kind>page</kind>
        <symbol>CreateTicketPage</symbol>
        <lines>all</lines>
        <reason>Existing create form template with Input, Textarea, Button, Card components. Static form with no submission logic. Needs: Zustand integration, form validation, loading states, error handling, navigation on success.</reason>
      </file>
      <file>
        <path>client/app/(main)/tickets/page.tsx</path>
        <kind>page</kind>
        <symbol>TicketsListPage</symbol>
        <lines>all</lines>
        <reason>Tickets list with empty state. Needs: "New Ticket" button in header or action area to navigate to /tickets/create. Uses Link from next/navigation.</reason>
      </file>
      <file>
        <path>client/src/core/components/ui/button.tsx</path>
        <kind>component</kind>
        <symbol>Button</symbol>
        <lines>all</lines>
        <reason>shadcn/ui Button with variants (default, secondary, ghost) and sizes. Used for "Generate Ticket" (default) and "Cancel" (ghost) buttons. Supports disabled state.</reason>
      </file>
      <file>
        <path>client/src/core/components/ui/input.tsx</path>
        <kind>component</kind>
        <symbol>Input</symbol>
        <lines>all</lines>
        <reason>shadcn/ui Input for title field. Supports placeholder, required, onChange handlers. Uses design tokens for styling.</reason>
      </file>
      <file>
        <path>client/src/core/components/ui/textarea.tsx</path>
        <kind>component</kind>
        <symbol>Textarea</symbol>
        <lines>all</lines>
        <reason>shadcn/ui Textarea for description field. Supports placeholder, rows, onChange handlers.</reason>
      </file>
      <file>
        <path>client/src/core/components/ui/card.tsx</path>
        <kind>component</kind>
        <symbol>Card</symbol>
        <lines>all</lines>
        <reason>Container component used in create form template. Provides subtle border and padding for form sections.</reason>
      </file>
      <file>
        <path>backend/src/tickets/presentation/controllers/tickets.controller.ts</path>
        <kind>controller</kind>
        <symbol>TicketsController</symbol>
        <lines>all</lines>
        <reason>NestJS controller with POST /api/tickets endpoint. Accepts CreateTicketDto (title, description), returns AEC response. Uses CreateTicketUseCase. Currently hardcoded workspaceId='ws_dev' (auth in Story 2.3).</reason>
      </file>
      <file>
        <path>backend/src/tickets/application/use-cases/CreateTicketUseCase.ts</path>
        <kind>use-case</kind>
        <symbol>CreateTicketUseCase</symbol>
        <lines>all</lines>
        <reason>Orchestrates ticket creation: creates draft AEC entity, initializes generation state, persists to Firestore. Returns AEC with id for navigation. TODO comment indicates 8-step generation will be added.</reason>
      </file>
      <file>
        <path>backend/src/tickets/domain/aec/AEC.ts</path>
        <kind>entity</kind>
        <symbol>AEC</symbol>
        <lines>all</lines>
        <reason>Domain entity with state machine. Factory method createDraft() validates title (3-500 chars), creates AEC with status='draft'. Has getters for all fields. Immutable from outside.</reason>
      </file>
      <file>
        <path>client/package.json</path>
        <kind>config</kind>
        <symbol>Dependencies</symbol>
        <lines>12-19</lines>
        <reason>Has axios (for HTTP calls), zustand (for state), next/react. Ready for ticket service implementation. May need @repo/shared-types for AEC type definitions.</reason>
      </file>
      <file>
        <path>client/src/stores/</path>
        <kind>directory</kind>
        <symbol>Empty directory</symbol>
        <lines>n/a</lines>
        <reason>Directory exists but empty. Will create tickets.store.ts here with Zustand store for ticket creation state.</reason>
      </file>
      <file>
        <path>client/src/services/</path>
        <kind>directory</kind>
        <symbol>Empty directory</symbol>
        <lines>n/a</lines>
        <reason>Directory exists but empty. Will create ticket.service.ts (API client) and index.ts (useServices hook) here.</reason>
      </file>
    </code>

    <dependencies>
      <node>
        <package name="next" version="^15.5.11" />
        <package name="react" version="^19.0.0" />
        <package name="zustand" version="^4.5.0" />
        <package name="axios" version="^1.6.5" />
        <package name="lucide-react" version="latest" />
      </node>
      <backend>
        <package name="@nestjs/common" version="^10.3.0" />
        <package name="@nestjs/core" version="^10.3.0" />
        <package name="firebase-admin" version="^12.0.0" />
        <package name="class-validator" version="^0.14.1" />
        <package name="zod" version="^3.22.4" />
      </backend>
      <note>All shadcn/ui component dependencies already installed from Epic 1. Backend POST /api/tickets endpoint ready. May need to add @repo/shared-types for type sharing between frontend/backend.</note>
    </dependencies>
  </artifacts>

  <constraints>
    - MANDATORY: Use dependency injection system via useServices() hook for all services
    - Use Zustand for state management with lazy service access in stores
    - NO business logic in UI components - all logic in store actions
    - Always handle loading, error, and empty states in components
    - Form validation must happen before API call (title ≥3 chars)
    - Use design tokens from Epic 1 (no hardcoded colors)
    - Linear minimalism: max-width 640px, generous whitespace, subtle borders
    - Error messages must be user-friendly (not technical)
    - Preserve form data on error (don't clear fields)
    - Navigate to /tickets/${aec.id} on successful creation
    - All new files under src/ per CLAUDE.md
    - File naming: kebab-case.ts for services/stores, PascalCase.tsx for components
  </constraints>

  <interfaces>
    <interface>
      <name>POST /api/tickets</name>
      <kind>REST API Endpoint</kind>
      <signature>POST /api/tickets { title: string, description?: string } → Response: AEC object with id, status='draft', generationState</signature>
      <path>backend/src/tickets/presentation/controllers/tickets.controller.ts</path>
    </interface>
    <interface>
      <name>useTicketsStore</name>
      <kind>Zustand Store Hook</kind>
      <signature>{ tickets: AEC[], isCreating: boolean, createError: string | null, createTicket: (title, description?) => Promise<void> }</signature>
      <path>client/src/stores/tickets.store.ts (to be created)</path>
    </interface>
    <interface>
      <name>TicketService</name>
      <kind>API Client Class</kind>
      <signature>class TicketService { create(data), getById(id), list() }</signature>
      <path>client/src/services/ticket.service.ts (to be created)</path>
    </interface>
    <interface>
      <name>useServices</name>
      <kind>Dependency Injection Hook</kind>
      <signature>function useServices(): { ticketService: TicketService }</signature>
      <path>client/src/services/index.ts (to be created)</path>
    </interface>
    <interface>
      <name>shadcn/ui components</name>
      <kind>UI Component Library</kind>
      <signature>Button (variants: default, ghost), Input, Textarea, Card</signature>
      <path>client/src/core/components/ui/*</path>
    </interface>
  </interfaces>

  <tests>
    <standards>
      Testing strategy: Unit tests for store actions (mock service), component tests for form validation and UI states, integration test for full create flow. Use Jest + React Testing Library. Co-locate tests with source files (.spec.ts/.spec.tsx). Test loading states, error states, success navigation.
    </standards>
    <locations>
      - Unit tests: client/src/stores/tickets.store.spec.ts, client/src/services/ticket.service.spec.ts
      - Component tests: client/app/(main)/tickets/create/page.spec.tsx
      - Integration tests: client/src/__tests__/ticket-creation.test.tsx
    </locations>
    <ideas>
      - AC#1: Test "New Ticket" button navigates to /tickets/create
      - AC#2: Test form renders with all required fields and buttons
      - AC#3: Test button disabled when title <3 chars, enabled when ≥3 chars
      - AC#4: Test createTicket store action calls ticket service with form data
      - AC#4: Test successful creation navigates to /tickets/{id}
      - AC#5: Test Cancel button navigates to /tickets without API call
      - AC#6: Test form uses design tokens (snapshot test or check className)
      - AC#7: Test error message displays when API fails
      - AC#7: Test retry preserves form data
      - Store: Mock TicketService, verify createTicket updates isCreating state
      - Service: Mock axios, verify POST called with correct data
      - Error: Mock API error, verify createError state set
    </ideas>
  </tests>
</story-context>
